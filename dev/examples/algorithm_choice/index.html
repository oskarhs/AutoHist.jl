<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Choice of algorithm · AutoHist.jl</title><meta name="title" content="Choice of algorithm · AutoHist.jl"/><meta property="og:title" content="Choice of algorithm · AutoHist.jl"/><meta property="twitter:title" content="Choice of algorithm · AutoHist.jl"/><meta name="description" content="Documentation for AutoHist.jl."/><meta property="og:description" content="Documentation for AutoHist.jl."/><meta property="twitter:description" content="Documentation for AutoHist.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">AutoHist.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introdution</a></li><li><a class="tocitem" href="../../methods/">Supported Methods</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../density_estimation/">Density estimation</a></li><li class="is-active"><a class="tocitem" href>Choice of algorithm</a><ul class="internal"><li><a class="tocitem" href="#The-cubic-time-dynamic-programming-algorithm"><span>The cubic-time dynamic programming algorithm</span></a></li><li><a class="tocitem" href="#The-quadratic-time-dynamic-programming-algorithm"><span>The quadratic-time dynamic programming algorithm</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../algorithms/">Algorithms</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Choice of algorithm</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Choice of algorithm</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/oskarhs/AutoHist.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/oskarhs/AutoHist.jl/blob/main/docs/src/examples/algorithm_choice.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Choice-of-algorithm"><a class="docs-heading-anchor" href="#Choice-of-algorithm">Choice of algorithm</a><a id="Choice-of-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Choice-of-algorithm" title="Permalink"></a></h1><p>In this section, we empirically assess the efficiency of the dynamic programming algorithm provided for irregular histograms, and show how heuristics can be used to speed up the computations.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><h2 id="The-cubic-time-dynamic-programming-algorithm"><a class="docs-heading-anchor" href="#The-cubic-time-dynamic-programming-algorithm">The cubic-time dynamic programming algorithm</a><a id="The-cubic-time-dynamic-programming-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-cubic-time-dynamic-programming-algorithm" title="Permalink"></a></h2><p>As a toy problem, we consider standard normal random samples of using a data-based grid. In this case, the number of candidate cutpoints are <span>$k_n = n+1$</span>, where <span>$n$</span> is the sample size. For smaller samples, we can just compute the exact solution using the default dynamic programming algorithm, available as <a href="../../algorithms/#AutoHist.SegNeig"><code>SegNeig</code></a>. The code snippet below illustrates how this algorithm can be explicitly specified when calling <code>fit</code>:</p><pre><code class="language-julia hljs">using AutoHist, Distributions, BenchmarkTools
n = 500
@benchmark fit(
    AutomaticHistogram, 
    $rand(Normal(), n),
    RIH(
        grid = :data,
        alg = SegNeig(greedy=false)
    )
)

# Output
BenchmarkTools.Trial: 55 samples with 1 evaluation per sample.
 Range (min … max):  51.734 ms … 235.103 ms  ┊ GC (min … max): 10.63% … 76.02%
 Time  (median):     57.087 ms               ┊ GC (median):    10.08%
 Time  (mean ± σ):   91.326 ms ±  66.481 ms  ┊ GC (mean ± σ):  43.70% ± 26.34%</code></pre><p>Benchmarking the above code snippet yields a median runtime of around <span>$57\ \text{ms}$</span> on my machine. Since dynamic programming is quick for samples of this size, the greedy algorithm will only be used if the number of candidate cutpoints exceeds <span>$501$</span>. Thus, changing <code>greedy</code> to <code>true</code> in the above code snippet would produce the same histogram, as there are <span>$501$</span> possible cutpoints.</p><h4 id="Speeding-up-computations-via-heuristics"><a class="docs-heading-anchor" href="#Speeding-up-computations-via-heuristics">Speeding up computations via heuristics</a><a id="Speeding-up-computations-via-heuristics-1"></a><a class="docs-heading-anchor-permalink" href="#Speeding-up-computations-via-heuristics" title="Permalink"></a></h4><p>The <span>$\mathcal{O}(k_n^3)$</span> runtime of dynamic programming means that computing the optimal solution quickly becomes computationally prohibitive, even for moderate samples. As an example, when doubling the number of samples in the above code snippet to <span>$n = 1000$</span>, the median runtime increases to <span>$442\ \text{ms}$</span>, a rougly <span>$8$</span>-fold increase. To ensure that the code retains good performance even for larger samples, we have implemented a greedy search heuristic which selects a subset of the candidate cutpoints, and the dynamic programming algorithm is subsequently run on this smaller set. Adopting the heuristic approach can improve performance considerably, but comes at the cost of no longer being guaranteed to find the optimal solution. To showcase the computational advantages of the heuristic approach, we run a benchmark on a normal sample of size <span>$n = 10^6$</span>.</p><pre><code class="language-julia hljs">n = 10^6
@benchmark fit(
    AutomaticHistogram, 
    $rand(Normal(), n),
    RIH(
        grid = :data,
        alg = SegNeig(greedy=true) # NB! greedy=true is the default option
    )
)

# Output
BenchmarkTools.Trial: 7 samples with 1 evaluation per sample.
 Range (min … max):  683.418 ms … 826.615 ms  ┊ GC (min … max):  1.71% … 19.55%
 Time  (median):     777.266 ms               ┊ GC (median):    11.38%
 Time  (mean ± σ):   765.973 ms ±  48.456 ms  ┊ GC (mean ± σ):  10.04% ±  6.39%</code></pre><p>As we can see, the median runtime is less than 2 times slower than the mean time it took to compute the exact solution for random samples of size <span>$n = 10^3$</span>.</p><p>The number candidate cutpoints constructed by the greedy search heuristic can be controlled through the <code>gr_maxbins</code> keyword argument, which equals the number of selected gridpoints plus one. By default, the greedy algorithm will produce a subset consisting of <span>$\max\{500, n^{1/3}\}+1$</span> cutpoints by default (including the edges). For <code>gr_maxbins1 &lt; gr_maxbins2</code>, the cutpoint subset formed by the greedy algorithm for <code>gr_maxbins1</code> is a subset of that selected with <code>gr_maxbins2</code> bins. Thus, increasing the number of candidate cutpoints added this grid will never lead to a worse solution of the original optimization problem. If additional precision is desired in the above example, we can increase <code>gr_maxbins</code> to <span>$1000$</span>:</p><pre><code class="language-julia hljs">n = 10^6
@benchmark fit(
    AutomaticHistogram, 
    $rand(Normal(), n),
    RIH(
        grid = :data,
        alg = SegNeig(greedy=true, gr_maxbins=10^3)
    )
)

# Output
BenchmarkTools.Trial: 5 samples with 1 evaluation per sample.
 Range (min … max):  1.114 s …   1.339 s  ┊ GC (min … max):  5.36% … 17.15%
 Time  (median):     1.270 s              ┊ GC (median):    15.61%
 Time  (mean ± σ):   1.232 s ± 99.117 ms  ┊ GC (mean ± σ):  12.38% ±  6.19%</code></pre><p>The above code snippet has a median runtime of about <span>$1.2\ \text{s}$</span> on my machine.</p><h2 id="The-quadratic-time-dynamic-programming-algorithm"><a class="docs-heading-anchor" href="#The-quadratic-time-dynamic-programming-algorithm">The quadratic-time dynamic programming algorithm</a><a id="The-quadratic-time-dynamic-programming-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-quadratic-time-dynamic-programming-algorithm" title="Permalink"></a></h2><p>For the <a href="../../methods/#AutoHist.L2CV_I"><code>L2CV_I</code></a> and <a href="../../methods/#AutoHist.KLCV_I"><code>KLCV_I</code></a> criteria, it becomes possible to compute the exact solution via the quadratic-time dynamic programming algorithm <code>OptPart</code> instead of the cubic-time <code>SegNeig</code> algorithm used for the other problems. In practice, this means that computing the exact solution is often feasible even as the number of candidate cutpoints becomes quite large. Both the <code>OptPart</code> and <code>SegNeig</code> algorithms can be used to fit <code>L2CV_I</code>, allowing us to get a direct comparison between the performance of the two algorithms.</p><pre><code class="language-julia hljs">n = 10^3
@benchmark fit(
    AutomaticHistogram, 
    $rand(Normal(), n),
    L2CV_I(
        grid = :data,
        alg = OptPart(greedy=false)
    )
)

@benchmark fit(
    AutomaticHistogram, 
    $rand(Normal(), n),
    L2CV_I(
        grid = :data,
        alg = SegNeig(greedy=false)
    )
)

# Output OptPart
BenchmarkTools.Trial: 1014 samples with 1 evaluation per sample.
 Range (min … max):  3.673 ms … 10.196 ms  ┊ GC (min … max):  0.00% … 33.51%
 Time  (median):     4.437 ms              ┊ GC (median):     0.00%
 Time  (mean ± σ):   4.921 ms ±  1.099 ms  ┊ GC (mean ± σ):  12.30% ± 15.90%

# Output SegNeig
BenchmarkTools.Trial: 11 samples with 1 evaluation per sample.
 Range (min … max):  408.000 ms … 570.588 ms  ┊ GC (min … max): 11.73% … 35.49%
 Time  (median):     421.996 ms               ┊ GC (median):    11.52%
 Time  (mean ± σ):   471.118 ms ±  68.395 ms  ┊ GC (mean ± σ):  22.00% ± 10.88%</code></pre><p>The mean runtime is around <span>$100$</span> times faster for the quadratic-time algorithm! Although the speedup from the quadratic-time algorithm is considerable in this case, it is often too slow to be used in practice for larger sample sizes. To speed up the computation for these criteria, it is once again possible to use the greedy search heuristic used in the cubic-time case. Due to the superior runtime complexity of the exact algorithm for cross-validation criteria, the exact solution is by default computed when the number of total candidate cutpoints is less than <span>$3001$</span>, and the greedy search heuristic is used thereafter to build a smaller candidate set as previously. By default <code>gr_maxbins</code> is set to <span>$\max\{3000, \sqrt{n}\}$</span>, but this can be replaced with a user-defined value if better performance or additional accuracy is desired.</p><div class="admonition is-info" id="Note-4b59dbb2ebfe063e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4b59dbb2ebfe063e" title="Permalink"></a></header><div class="admonition-body"><p>In practice one should of course never use the <code>SegNeig</code> algorithm for the two cross-validation criteria, as it only leads to a reduction in speed compared to using <code>OptPart</code>, which is the default.</p></div></div><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><strong>Note:</strong> The benchmarks presented here were performed on a Windows machine with a Intel® Core™ Ultra 5 125U CPU. Results may vary on systems with different hardware configurations.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../density_estimation/">« Density estimation</a><a class="docs-footer-nextpage" href="../../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Wednesday 23 July 2025 20:51">Wednesday 23 July 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
