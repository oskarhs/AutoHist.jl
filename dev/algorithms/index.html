<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithms · AutoHist.jl</title><meta name="title" content="Algorithms · AutoHist.jl"/><meta property="og:title" content="Algorithms · AutoHist.jl"/><meta property="twitter:title" content="Algorithms · AutoHist.jl"/><meta name="description" content="Documentation for AutoHist.jl."/><meta property="og:description" content="Documentation for AutoHist.jl."/><meta property="twitter:description" content="Documentation for AutoHist.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="AutoHist.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="AutoHist.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AutoHist.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../methods/">Supported Methods</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/plotting/">Plotting tutorial</a></li><li><a class="tocitem" href="../examples/density_estimation/">Density estimation</a></li><li><a class="tocitem" href="../examples/algorithm_choice/">Choice of algorithm</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li class="is-active"><a class="tocitem" href>Algorithms</a><ul class="internal"><li><a class="tocitem" href="#Problem-description"><span>Problem description</span></a></li><li><a class="tocitem" href="#Segment-neighbourhood"><span>Segment neighbourhood</span></a></li><li><a class="tocitem" href="#Optimal-partitioning"><span>Optimal partitioning</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/oskarhs/AutoHist.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/oskarhs/AutoHist.jl/blob/main/docs/src/algorithms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithms-for-constructing-irregular-histograms"><a class="docs-heading-anchor" href="#Algorithms-for-constructing-irregular-histograms">Algorithms for constructing irregular histograms</a><a id="Algorithms-for-constructing-irregular-histograms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms-for-constructing-irregular-histograms" title="Permalink"></a></h1><p>Constructing data-adaptive irregular histograms is in general a difficult problem from a computational perspective, and as a result computing the exact optimal partition is often impractical for larger sample sizes. This package solves the problem of irregular histogram construction via heuristics that combine a greedy search procedure with dynamic programming techniques to quickly compute a nearly optimal partition. Examples showcasing the use of the provided algorithms in toy problems can be found <a href="../examples/algorithm_choice/">here</a>. Note that the default option for the <code>alg</code> keyword offers a reasonable tradeoff between accuracy and computational efficiency, and in cases where one simply wants to draw an irregular histogram quickly for a given dataset, these default choices will typically yield a reasonable density estimate within a reasonable amount of time. However, if better performance or additional accuracy is desired, then a more fine-tuned approach to selecting the algorithm used and its hyperparameters is needed.</p><h2 id="Problem-description"><a class="docs-heading-anchor" href="#Problem-description">Problem description</a><a id="Problem-description-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-description" title="Permalink"></a></h2><p>All the irregular histogram methods supported by this library are the product of solving an optimization problem of the form</p><p class="math-container">\[    \max_{1\leq k\leq k_n}\max_{\boldsymbol{t}_{0:k}} \Big\{\sum_{j=1}^k \Phi(\tau_{n, t_{j-1}}, \tau_{n, t_{j}}] + \Psi(k)\Big\},\]</p><p>where the inner maximum is over integer vectors <span>$\boldsymbol{t}_{0:k}$</span> satisfying <span>$0 = t_0 &lt; t_1 &lt; \cdots &lt; t_{k-1} &lt; t_k = k_n$</span> and <span>$\{\tau_{n,j}\colon 0\leq j \leq k_n\}$</span> are the candidate cutpoints between the partition intervals. While it is generally desirable to use a moderate number of possible cutpoints relative to the number of samples, this comes at a heavy computational cost if an exact solution of the above optimization is desired as the runtime complexity of the algorithm is cubic in the number of candidates. We note that for the special case where <span>$\Psi(k) = \beta k$</span> for some scalar <span>$\beta\in \mathbb{R}$</span> and all <span>$k\in \mathbb{N}$</span>, a more efficient algorithm is available, allowing for a quadratic-time solution. In both cases, computing the exact solution becomes unfeasible for larger sample sizes.</p><p>To ease the computational burden we adopt a greedy search heuristic to construct a subset of possible cutpoints when the number of candidates is large, and then run the optimization algorithm of choice on this smaller set. To find the optimal partition for a given set of candidate cutpoints, this package includes two solvers based on dynamic programming. The algorithm used can be controlled via the <code>alg</code> keyword passed to the rule argument of <a href="../api/#StatsAPI.fit-Tuple{Type{AutomaticHistogram}, AbstractVector{&lt;:Real}, AutoHist.AbstractRule}"><code>fit</code></a>, see the <a href="../methods/#irregular-histograms">methods page</a>.</p><h2 id="Segment-neighbourhood"><a class="docs-heading-anchor" href="#Segment-neighbourhood">Segment neighbourhood</a><a id="Segment-neighbourhood-1"></a><a class="docs-heading-anchor-permalink" href="#Segment-neighbourhood" title="Permalink"></a></h2><p>The choice <code>alg = SegNeig()</code> results in the use of the exact dynamic programming algorithm of <a href="https://doi.org/10.1080/03610928808829688">Kanazawa (1988)</a> to find the optimal partition. Runtime complexity is cubic in the number of candidate cutpoints.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.SegNeig" href="#AutoHist.SegNeig"><code>AutoHist.SegNeig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SegNeig(; greedy::Bool=true, gr_maxbins::Union{Int, Symbol}=:default)</code></pre><p>The segment neighbourhood algorithm for constructing an irregular histogram.</p><p><strong>Keyword arguments</strong></p><ul><li><code>greedy</code>: Boolean indicating whether or not the greedy cutpoint selection strategy of <a href="https://doi.org/10.1016/j.csda.2010.04.021">Rozenholc et al. (2010)</a> should be used to select a smaller number of candidate cutpoints prior to running the dynamic programming algorithm. Defaults to <code>true</code>.</li><li><code>gr_maxbins</code>: Number of candidate cutpoints chosen by the greedy algorithm. Supplying <code>gr_maxbins=:default</code> results in the selection of at most <span>$\max\{ 500, n^{1/3} \}+1$</span> candidate cutpoints (including edges).</li></ul><div class="admonition is-info" id="Note-926efde2fc28ae33"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-926efde2fc28ae33" title="Permalink"></a></header><div class="admonition-body"><p>This algorithm can be quite slow for large datasets when the <code>greedy</code> keyword is set to <code>false</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = LinRange(eps(), 1.0-eps(), 5000) .^(1.0/4.0);

julia&gt; h = fit(AutomaticHistogram, x, RIH(alg = SegNeig(greedy=true, gr_maxbins=200)))
AutomaticHistogram{Vector{Float64}, Vector{Float64}, Vector{Int64}}
breaks: [0.0001220703125, 0.17763663029325183, 0.29718725232110504, 0.4022468898607337, 0.4928155429121377, 0.5797614498414855, 0.6667073567708333, 0.7572760098222373, 0.8405991706295289, 0.9239223314368207, 1.0]
density: [0.006626835974128547, 0.057821970706400425, 0.17596277991076312, 0.36279353706969375, 0.6214544825215076, 0.9730458529384184, 1.4481767793920146, 2.0440057561776532, 2.7513848134529346, 3.5648421829491657]
counts: [5, 34, 92, 164, 270, 423, 656, 852, 1147, 1357]
type: irregular
closed: right
a: 5.0

julia&gt; h = fit(AutomaticHistogram, x, RIH(alg = SegNeig(greedy=false)))
AutomaticHistogram{Vector{Float64}, Vector{Float64}, Vector{Int64}}
breaks: [0.0001220703125, 0.17763663029325183, 0.29718725232110504, 0.4022468898607337, 0.4928155429121377, 0.5797614498414855, 0.6667073567708333, 0.7572760098222373, 0.8405991706295289, 0.9202995853147645, 1.0]
density: [0.006626835974128547, 0.057821970706400425, 0.17596277991076312, 0.36279353706969375, 0.6214544825215076, 0.9730458529384184, 1.4481767793920146, 2.0440057561776532, 2.733509595364622, 3.545742066060377]
counts: [5, 34, 92, 164, 270, 423, 656, 852, 1090, 1414]
type: irregular
closed: right
a: 5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/2ae259de82d747367480f8a14ca24c172e40d180/src/irregular/algorithms.jl#L63-L97">source</a></section></article><h2 id="Optimal-partitioning"><a class="docs-heading-anchor" href="#Optimal-partitioning">Optimal partitioning</a><a id="Optimal-partitioning-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-partitioning" title="Permalink"></a></h2><p>The choice <code>alg = OptPart()</code> results in the use of the exact optimal partitioning algorithm of <a href="https://doi.org/10.1109/LSP.2001.838216">Jackson et al. (2005)</a> to find the optimal histogram partition. This algorithm solves a less general optimization problem than the <code>SegNeig</code> algorithm. Runtime complexity is quadratic in the number of candidate cutpoints.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.OptPart" href="#AutoHist.OptPart"><code>AutoHist.OptPart</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OptPart(; greedy::Bool=true, gr_maxbins::Union{Int, Symbol}=:default)</code></pre><p>The optimal partitioning algorithm for constructing an irregular histogram.</p><p><strong>Keyword arguments</strong></p><ul><li><code>greedy</code>: Boolean indicating whether or not the greedy cutpoint selection strategy of <a href="https://doi.org/10.1016/j.csda.2010.04.021">Rozenholc et al. (2010)</a> should be used to select a smaller number of candidate cutpoints prior to running the dynamic programming algorithm. Defaults to <code>true</code>.</li><li><code>gr_maxbins</code>: Number of candidate cutpoints chosen by the greedy algorithm. Supplying <code>gr_maxbins=:default</code> results in the selection of at most <span>$\max \{ 3000, n^{1/2} \}+1$</span> candidate cutpoints (including edges).</li></ul><div class="admonition is-info" id="Note-926efde2fc28ae33"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-926efde2fc28ae33" title="Permalink"></a></header><div class="admonition-body"><p>This algorithm can be quite slow for large datasets when the <code>greedy</code> keyword is set to <code>false</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = LinRange(eps(), 1.0-eps(), 1000) .^(1.0/4.0);

julia&gt; h = fit(AutomaticHistogram, x, L2CV_I(alg = OptPart(greedy=true, gr_maxbins=100)))
AutomaticHistogram{Vector{Float64}, Vector{Float64}, Vector{Int64}}
breaks: [0.0001220703125, 0.16676839192708331, 0.2977047874813988, 0.4048345656622024, 0.5119643438430059, 0.6071908133370535, 0.6786106654575893, 0.7619338262648809, 0.8452569870721726, 0.9285801478794643, 1.0]
density: [0.006000732511292883, 0.05346107146424569, 0.17735498311154516, 0.3920478574044684, 0.7035858869490909, 1.0641298986692698, 1.5001831278232214, 2.0762534489073383, 2.7963413502624808, 3.5984392626052997]
counts: [1, 7, 19, 42, 67, 76, 125, 173, 233, 257]
type: irregular
closed: right
a: NaN

julia&gt; h = fit(AutomaticHistogram, x, L2CV_I(alg = OptPart(greedy=false)))
AutomaticHistogram{Vector{Float64}, Vector{Float64}, Vector{Int64}}
breaks: [0.0001220703125, 0.16676839192708331, 0.2977047874813988, 0.4048345656622024, 0.5119643438430059, 0.6071908133370535, 0.6786106654575893, 0.7619338262648809, 0.8452569870721726, 0.9285801478794643, 1.0]
density: [0.006000732511292883, 0.05346107146424569, 0.17735498311154516, 0.3920478574044684, 0.7035858869490909, 1.0641298986692698, 1.5001831278232214, 2.0762534489073383, 2.7963413502624808, 3.5984392626052997]
counts: [1, 7, 19, 42, 67, 76, 125, 173, 233, 257]
type: irregular
closed: right
a: NaN</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/2ae259de82d747367480f8a14ca24c172e40d180/src/irregular/algorithms.jl#L9-L43">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Thursday 18 September 2025 10:28">Thursday 18 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
