<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Supported Methods · AutoHist.jl</title><meta name="title" content="Supported Methods · AutoHist.jl"/><meta property="og:title" content="Supported Methods · AutoHist.jl"/><meta property="twitter:title" content="Supported Methods · AutoHist.jl"/><meta name="description" content="Documentation for AutoHist.jl."/><meta property="og:description" content="Documentation for AutoHist.jl."/><meta property="twitter:description" content="Documentation for AutoHist.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="AutoHist.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="AutoHist.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AutoHist.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Supported Methods</a><ul class="internal"><li><a class="tocitem" href="#Irregular-histograms"><span>Irregular histograms</span></a></li><li><a class="tocitem" href="#Regular-histograms"><span>Regular histograms</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/plotting/">Plotting tutorial</a></li><li><a class="tocitem" href="../examples/density_estimation/">Density estimation</a></li><li><a class="tocitem" href="../examples/algorithm_choice/">Choice of algorithm</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Supported Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Supported Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/oskarhs/AutoHist.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/oskarhs/AutoHist.jl/blob/main/docs/src/methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Supported-Methods"><a class="docs-heading-anchor" href="#Supported-Methods">Supported Methods</a><a id="Supported-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-Methods" title="Permalink"></a></h1><p>This page provides background on each histogram method supported through the <code>rule</code> argument. Our presentation is intended to be rather brief, and we therefore do not cover the theoretical underpinnings of each method in great detail. For some further background on automatic histogram procedures and the theory behind them, we recommend the excellent reviews contained in the articles of <a href="https://doi.org/10.1016/j.csda.2010.04.021">Birgé and Rozenholc (2006)</a> and <a href="https://doi.org/10.1051/ps:2008005">Davies et al. (2009)</a>.</p><p>For ease of exposition, we present all methods covered here in the context of estimating the density of a sample <span>$\boldsymbol{x} = (x_1, x_2, \ldots, x_n)$</span> on the unit interval, but note that extending the procedures presented here to other compact intervals is possible through a suitable affine transformation. In particular, if a density estimate with support <span>$[a,b]$</span> is desired, we can scale the data to the unit interval through <span>$z_i = (x_i - a)/(b-a)$</span>, and apply the methods on this transformed sample and rescale the resulting density estimate to <span>$[a,b]$</span>. In cases where the support of the density is unknown, a natural choice is <span>$a = x_{(1)}$</span> and <span>$b = x_{(n)}$</span>. Cases where only the lower or upper bound is known can be handled similarly. The transformation used to construct the histogram can be controlled through the <code>support</code> keyword, where the default argument <code>support=(-Inf, Inf)</code> uses the order statistics-based approach described above.</p><h4 id="Notation"><a class="docs-heading-anchor" href="#Notation">Notation</a><a id="Notation-1"></a><a class="docs-heading-anchor-permalink" href="#Notation" title="Permalink"></a></h4><p>Before we describe the methods included here in more detail, we introduce some notation. We let <span>$\mathcal{I} = (\mathcal{I}_1, \mathcal{I}_2, \ldots, \mathcal{I}_k)$</span> denote a partition of <span>$[0,1]$</span> into <span>$k$</span> intervals and write <span>$|\mathcal{I}_j|$</span> for the length of interval <span>$\mathcal{I}_j$</span>. The intervals in the partition <span>$\mathcal{I}$</span> can be either right- or left-closed. Whether a left- or right-closed partition is used to draw the histogram is controlled by the keyword argument <code>closed</code>, with options <code>:left</code> and <code>:right</code> (default). This choice is somewhat arbitrary, but is unlikely to matter much in practical applications.</p><p>Based on a partition <span>$\mathcal{I}$</span>, we can write down the corresponding histogram density estimate by</p><p class="math-container">\[\widehat{f}(x) = \sum_{j=1}^k \frac{\widehat{\theta}_j}{|\mathcal{I}_j|}\mathbf{1}_{\mathcal{I}_j}(x), \quad x\in [0,1],\]</p><p>where <span>$\mathbf{1}_{\mathcal{I}_j}$</span> is the indicator function, <span>$\widehat{\theta}_j \geq 0$</span> for all <span>$j$</span> and <span>$\sum_{j=1}^k \widehat{\theta}_j = 1$</span>. </p><p>For most of the methods considered here, the estimated bin probabilities are the maximum likelihood estimates <span>$\widehat{\theta}_j = N_j/n$</span>, where <span>$N_j = \sum_{i=1}^n \mathbb{1}_{\mathcal{I}_j}(x_i)$</span> is the number of observations landing in interval <span>$\mathcal{I}_j$</span> . The exception to this rule are the two Bayesian approaches <a href="#AutoHist.RIH"><code>RIH</code></a> and <a href="#AutoHist.RRH"><code>RRH</code></a>, which uses the Bayes estimator <span>$\widehat{\theta}_j = (a_j + N_j)/(a+n)$</span> for <span>$(a_1, \ldots, a_k) \in (0,\infty)^k$</span> and <span>$a = \sum_{j=1}^k a_j$</span> instead.</p><p>The goal of an automatic histogram procedure is to find a partition <span>$\mathcal{I}$</span> based on the sample alone which produces a reasonable density estimate. Regular histogram procedures only consider regular partitions, where all intervals in the partition are of equal length, so that one only needs to determine the number <span>$k$</span> of bins. Irregular histograms allow for partitions with intervals of unequal length, and try to determine both the number of bins and the locations of the cutpoints between the intervals.</p><h4 id="A-short-note-on-using-different-rules"><a class="docs-heading-anchor" href="#A-short-note-on-using-different-rules">A short note on using different rules</a><a id="A-short-note-on-using-different-rules-1"></a><a class="docs-heading-anchor-permalink" href="#A-short-note-on-using-different-rules" title="Permalink"></a></h4><p>In order to fit a histogram using a specific <code>rule</code>, we call <code>fit(AutomaticHistogram, x, rule)</code>, where <code>x</code> is the data vector. For many of the rules discussed below, the user can specify additional rule-specific keywords to <code>rule</code>, providing additional control over the supplied method when desired. We also provide a set of default values for these parameters, so that the user may for instance call <code>fit(AutomaticHistogram, x, AIC())</code> to fit a regular histogram using the AIC criterion without having to worry about explicitly passing any keyword arguments.</p><h2 id="Irregular-histograms"><a class="docs-heading-anchor" href="#Irregular-histograms">Irregular histograms</a><a id="Irregular-histograms-1"></a><a class="docs-heading-anchor-permalink" href="#Irregular-histograms" title="Permalink"></a></h2><p>The following section provides a description of all the irregular histogram rules that have been implemented in AutoHist.jl. In each case, the best partition is selected among the subset of interval partitions of the unit interval that have cut points belonging to a discrete set of cardinality <span>$k_n-1$</span>. In all the irregular procedures covered here, we attempt to find best partition according to a goodness-of-fit criterion among all partitions with endpoints belonging to a given discrete mesh <span>$\{\tau_{j}\colon 0\leq j \leq k_n\}$</span>.</p><h4 id="Random-irregular-histogram"><a class="docs-heading-anchor" href="#Random-irregular-histogram">Random irregular histogram</a><a id="Random-irregular-histogram-1"></a><a class="docs-heading-anchor-permalink" href="#Random-irregular-histogram" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.RIH" href="#AutoHist.RIH"><code>AutoHist.RIH</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RIH(;
    a::Real                    = 5.0,
    logprior::Function         = k -&gt; 0.0,
    grid::Symbol               = :regular,
    maxbins::Union{Int,Symbol} = :default,
    alg::AbstractAlgorithm     = SegNeig()
)</code></pre><p>The random irregular histogram criterion.</p><p>Consists of maximizing the marginal log-posterior of the partition <span>$\mathcal{I} = (\mathcal{I}_1, \ldots, \mathcal{I}_k)$</span>,</p><p class="math-container">\[    \sum_{j=1}^k \big\{\log \Gamma(a_j + N_j) - \log \Gamma(a_j) - N_j\log|\mathcal{I}_j|\big\} + \log p_n(k) - \log \binom{k_n-1}{k-1}\]</p><p>Here <span>$p_n(k)$</span> is the prior distribution on the number <span>$k$</span> of bins, which can be controlled by supplying a function to the <code>logprior</code> keyword argument.  The default value is <span>$p_n(k) \propto 1$</span>. Here, <span>$a_j = a/k$</span>, for a scalar <span>$a &gt; 0$</span>, not depending on <span>$k$</span>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>a</code>: Specifies Dirichlet concentration parameter in the Bayesian histogram model. Must be a fixed positive number, and defaults to <code>a=5.0</code>.</li><li><code>logprior</code>: Unnormalized logprior distribution on the number <span>$k$</span> of bins. Defaults to a uniform prior, e.g. <code>logprior(k) = 0</code> for all <code>k</code>.</li><li><code>grid</code>: Symbol indicating how the finest possible mesh should be constructed. Options are <code>:data</code>, which uses each unique data point as a grid point, <code>:regular</code> (default) which constructs a fine regular grid, and <code>:quantile</code> which constructs the grid based on the sample quantiles.</li><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code> if <code>grid</code> is <code>regular</code> or <code>quantile</code>. Ignored if <code>grid=:data</code>.</li><li><code>alg</code>: Algorithm used to fit the model. Currently, only <a href="../algorithms/#AutoHist.SegNeig"><code>SegNeig</code></a> is supported for this rule.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; rule = RIH(a = 5.0, logprior = k-&gt; -log(k), grid = :data);

julia&gt; fit(AutomaticHistogram, x, rule)
AutomaticHistogram{Vector{Float64}, Vector{Float64}, Vector{Int64}}
breaks: [0.0, 0.18220071105959446, 0.3587941358096334, 0.8722292888743843, 1.0]
density: [0.11858322346056327, 0.6490600487586273, 1.6066011289666577, 0.30436411114439915]
counts: [10, 57, 414, 19]
type: irregular
closed: right
a: 5.0</code></pre><p><strong>References</strong></p><p>This approach to irregular histograms first appeared in <a href="https://doi.org/10.48550/ARXIV.2505.22034">Simensen et al. (2025)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/irregular/irregular_rules.jl#L12-L56">source</a></section></article><h4 id="Rozenholc,-Mildenberger-and-Gather-penalty-A"><a class="docs-heading-anchor" href="#Rozenholc,-Mildenberger-and-Gather-penalty-A">Rozenholc, Mildenberger &amp; Gather penalty A</a><a id="Rozenholc,-Mildenberger-and-Gather-penalty-A-1"></a><a class="docs-heading-anchor-permalink" href="#Rozenholc,-Mildenberger-and-Gather-penalty-A" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.RMG_penA" href="#AutoHist.RMG_penA"><code>AutoHist.RMG_penA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RMG_penA(;
    grid::Symbol               = :regular,
    maxbins::Union{Int,Symbol} = :default,
    alg::AbstractAlgorithm     = SegNeig()
)</code></pre><p>Consists of finding the partition <span>$\mathcal{I}$</span> that maximizes a penalized log-likelihood,</p><p class="math-container">\[    \sum_{j=1}^k N_j \log (N_j/|\mathcal{I}_j|) - \log \binom{k_n-1}{k-1} - k - 2\log(k) - \sqrt{2(k-1)\Big[\log \binom{k_n-1}{k-1}+ 2\log(k)\Big]}.\]</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: Symbol indicating how the finest possible mesh should be constructed. Options are <code>:data</code>, which uses each unique data point as a grid point, <code>:regular</code> (default) which constructs a fine regular grid, and <code>:quantile</code> which constructs the grid based on the sample quantiles.</li><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code> if <code>grid</code> is <code>regular</code> or <code>quantile</code>. Ignored if <code>grid=:data</code>.</li><li><code>alg</code>: Algorithm used to fit the model. Currently, only <a href="../algorithms/#AutoHist.SegNeig"><code>SegNeig</code></a> is supported for this rule.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; rule = RMG_penA(grid = :data);

julia&gt; fit(AutomaticHistogram, x, rule)
AutomaticHistogram{Vector{Float64}, Vector{Float64}, Vector{Int64}}
breaks: [0.0, 0.18875598171056715, 0.3644223879547405, 0.8696799410193466, 1.0]
density: [0.116552597701164, 0.6717277510418354, 1.6229346697072502, 0.30693663211078037]
counts: [11, 59, 410, 20]
type: irregular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>This approach was suggested by <a href="https://doi.org/10.1016/j.csda.2010.04.021">Rozenholc et al. (2010)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/irregular/irregular_rules.jl#L101-L136">source</a></section></article><h4 id="Rozenholc,-Mildenberger-and-Gather-penalty-B"><a class="docs-heading-anchor" href="#Rozenholc,-Mildenberger-and-Gather-penalty-B">Rozenholc, Mildenberger &amp; Gather penalty B</a><a id="Rozenholc,-Mildenberger-and-Gather-penalty-B-1"></a><a class="docs-heading-anchor-permalink" href="#Rozenholc,-Mildenberger-and-Gather-penalty-B" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.RMG_penB" href="#AutoHist.RMG_penB"><code>AutoHist.RMG_penB</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RMG_penB(;
    grid::Symbol               = :regular,
    maxbins::Union{Int,Symbol} = :default,
    alg::AbstractAlgorithm     = SegNeig()
)</code></pre><p>Consists of finding the partition <span>$\mathcal{I}$</span> that maximizes a penalized log-likelihood,</p><p class="math-container">\[    \sum_{j=1}^k N_j \log (N_j/|\mathcal{I}_j|) - \log \binom{k_n-1}{k-1} - k - \log^{2.5}(k).\]</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: Symbol indicating how the finest possible mesh should be constructed. Options are <code>:data</code>, which uses each unique data point as a grid point, <code>:regular</code> (default) which constructs a fine regular grid, and <code>:quantile</code> which constructs the grid based on the sample quantiles.</li><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code> if <code>grid</code> is <code>regular</code> or <code>quantile</code>. Ignored if <code>grid=:data</code>.</li><li><code>alg</code>: Algorithm used to fit the model. Currently, only <a href="../algorithms/#AutoHist.SegNeig"><code>SegNeig</code></a> is supported for this rule.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; rule = RMG_penB(grid = :data);

julia&gt; fit(AutomaticHistogram, x, rule)
AutomaticHistogram{Vector{Float64}, Vector{Float64}, Vector{Int64}}
breaks: [0.0, 0.1948931612779725, 0.375258352661302, 0.8268306249022703, 0.9222490305512866, 1.0]
density: [0.12314439276691318, 0.7096713008662634, 1.6962954704872724, 0.7545714006671028, 0.12861575966067232]
counts: [12, 64, 383, 36, 5]
type: irregular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>This approach was suggested by <a href="https://doi.org/10.1016/j.csda.2010.04.021">Rozenholc et al. (2010)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/irregular/irregular_rules.jl#L177-L212">source</a></section></article><h4 id="Rozenholc,-Mildenberger-and-Gather-penalty-R"><a class="docs-heading-anchor" href="#Rozenholc,-Mildenberger-and-Gather-penalty-R">Rozenholc, Mildenberger &amp; Gather penalty R</a><a id="Rozenholc,-Mildenberger-and-Gather-penalty-R-1"></a><a class="docs-heading-anchor-permalink" href="#Rozenholc,-Mildenberger-and-Gather-penalty-R" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.RMG_penR" href="#AutoHist.RMG_penR"><code>AutoHist.RMG_penR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RMG_penR(;
    grid::Symbol               = :regular,
    maxbins::Union{Int,Symbol} = :default,
    alg::AbstractAlgorithm     = SegNeig()
)</code></pre><p>Consists of finding the partition <span>$\mathcal{I}$</span> that maximizes a penalized log-likelihood,</p><p class="math-container">\[    \sum_{j=1}^k \big\{N_j \log (N_j/|\mathcal{I}_j|) - \frac{N_j}{2n}\big\} - \log \binom{k_n-1}{k-1} - \log^{2.5}(k).\]</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: Symbol indicating how the finest possible mesh should be constructed. Options are <code>:data</code>, which uses each unique data point as a grid point, <code>:regular</code> (default) which constructs a fine regular grid, and <code>:quantile</code> which constructs the grid based on the sample quantiles.</li><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code> if <code>grid</code> is <code>regular</code> or <code>quantile</code>. Ignored if <code>grid=:data</code>.</li><li><code>alg</code>: Algorithm used to fit the model. Currently, only <a href="../algorithms/#AutoHist.SegNeig"><code>SegNeig</code></a> is supported for this rule.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; rule = RMG_penR(grid = :data);

julia&gt; fit(AutomaticHistogram, x, rule)
AutomaticHistogram{Vector{Float64}, Vector{Float64}, Vector{Int64}}
breaks: [0.0, 0.18875598171056715, 0.3699070396003733, 0.8285645195146814, 0.9222490305512866, 1.0]
density: [0.116552597701164, 0.6845115973621804, 1.6875338000474953, 0.7471886144834441, 0.12861575966067232]
counts: [11, 62, 387, 35, 5]
type: irregular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>This approach was suggested by <a href="https://doi.org/10.1016/j.csda.2010.04.021">Rozenholc et al. (2010)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/irregular/irregular_rules.jl#L253-L288">source</a></section></article><h4 id="Irregular-L_2-leave-one-out-cross-validation-(L2CV_I)"><a class="docs-heading-anchor" href="#Irregular-L_2-leave-one-out-cross-validation-(L2CV_I)">Irregular <span>$L_2$</span> leave-one-out cross-validation (L2CV_I)</a><a id="Irregular-L_2-leave-one-out-cross-validation-(L2CV_I)-1"></a><a class="docs-heading-anchor-permalink" href="#Irregular-L_2-leave-one-out-cross-validation-(L2CV_I)" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.L2CV_I" href="#AutoHist.L2CV_I"><code>AutoHist.L2CV_I</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">L2CV_I(;
    grid::Symbol               = :regular,
    maxbins::Union{Int,Symbol} = :default,
    alg::AbstractAlgorithm     = OptPart(),
    use_min_length::Bool       = false
)</code></pre><p>Consists of finding the partition <span>$\mathcal{I}$</span> that maximizes a L2 leave-one-out cross-validation criterion,</p><p class="math-container">\[    \frac{n+1}{n}\sum_{j=1}^k \frac{N_j^2}{|\mathcal{I}_j|} - 2\sum_{j=1}^k \frac{N_j}{|\mathcal{I}_j|}.\]</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: Symbol indicating how the finest possible mesh should be constructed. Options are <code>:data</code>, which uses each unique data point as a grid point, <code>:regular</code> (default) which constructs a fine regular grid, and <code>:quantile</code> which constructs the grid based on the sample quantiles.</li><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code> if <code>grid</code> is <code>regular</code> or <code>quantile</code>. Ignored if <code>grid=:data</code>.</li><li><code>alg</code>: Algorithm used to fit the model. Currently, <a href="../algorithms/#AutoHist.OptPart"><code>OptPart</code></a> and <a href="../algorithms/#AutoHist.SegNeig"><code>SegNeig</code></a> are supported for this rule, with the former algorithm being the default.</li><li><code>use_min_length</code>: Boolean indicating whether or not to impose a restriction on the minimum bin length of the histogram. If set to true, the smallest allowed bin length is set to <code>(maximum(x)-minimum(x))/n*log(n)^(1.5)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; rule = L2CV_I(grid = :data, use_min_length=true);

julia&gt; fit(AutomaticHistogram, x, rule)
AutomaticHistogram{Vector{Float64}, Vector{Float64}, Vector{Int64}}
breaks: [0.0, 0.149647045210915, 0.2499005080461325, 0.3490626376697454, 0.4600140220788484, 0.7765683248449301, 0.8535131937737716, 0.9121099383916996, 0.9560732934980348, 1.0]
density: [0.08018868653963065, 0.3590898407087615, 0.7664216197097746, 1.2798398213438569, 1.8448651460332468, 1.2476465466304287, 0.6826317786220794, 0.2729545998246794, 0.045530388214070294]
counts: [6, 18, 38, 71, 292, 48, 20, 6, 1]
type: irregular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>This approach dates back to <a href="https://www.jstor.org/stable/4615859">Rudemo (1982)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/irregular/irregular_rules.jl#L410-L447">source</a></section></article><h4 id="Irregular-Kullback-Leibler-leave-one-out-cross-validation-(KLCV_I)"><a class="docs-heading-anchor" href="#Irregular-Kullback-Leibler-leave-one-out-cross-validation-(KLCV_I)">Irregular Kullback-Leibler leave-one-out cross-validation (KLCV_I)</a><a id="Irregular-Kullback-Leibler-leave-one-out-cross-validation-(KLCV_I)-1"></a><a class="docs-heading-anchor-permalink" href="#Irregular-Kullback-Leibler-leave-one-out-cross-validation-(KLCV_I)" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.KLCV_I" href="#AutoHist.KLCV_I"><code>AutoHist.KLCV_I</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KLCV_I(;
    grid::Symbol               = :regular,
    maxbins::Union{Int,Symbol} = :default,
    alg::AbstractAlgorithm     = OptPart(),
    use_min_length::Bool       = false
)</code></pre><p>Consists of finding the partition <span>$\mathcal{I}$</span> that maximizes a Kullback-Leibler leave-one-out cross-validation criterion,</p><p class="math-container">\[    \sum_{j=1}^k N_j\log(N_j-1) - \sum_{j=1}^k N_j\log |\mathcal{I}_j|,\]</p><p>where the maximmization is over all partitions with <span>$N_j \geq 2$</span> for all <span>$j$</span>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: Symbol indicating how the finest possible mesh should be constructed. Options are <code>:data</code>, which uses each unique data point as a grid point, <code>:regular</code> (default) which constructs a fine regular grid, and <code>:quantile</code> which constructs the grid based on the sample quantiles.</li><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code> if <code>grid</code> is <code>regular</code> or <code>quantile</code>. Ignored if <code>grid=:data</code>.</li><li><code>alg</code>: Algorithm used to fit the model. Currently, <a href="../algorithms/#AutoHist.OptPart"><code>OptPart</code></a> and <a href="../algorithms/#AutoHist.SegNeig"><code>SegNeig</code></a> are supported for this rule, with the former algorithm being the default.</li><li><code>use_min_length</code>: Boolean indicating whether or not to impose a restriction on the minimum bin length of the histogram. If set to true, the smallest allowed bin length is set to <code>(maximum(x)-minimum(x))/n*log(n)^(1.5)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; rule = KLCV_I(grid = :data, use_min_length=true);

julia&gt; fit(AutomaticHistogram, x, rule)
AutomaticHistogram{Vector{Float64}, Vector{Float64}, Vector{Int64}}
breaks: [0.0, 0.13888886265725095, 0.23836051747480758, 0.33883651300547, 0.45084951551151237, 0.7900230337213711, 0.8722292888743843, 0.9352920770792058, 1.0]
density: [0.07200001359848368, 0.321699684786505, 0.7165890680628054, 1.2319998295961743, 1.8220762141507212, 1.1191362485586687, 0.5074307830485909, 0.09272434856770642]
counts: [5, 16, 36, 69, 309, 46, 16, 3]
type: irregular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>This approach to irregular histograms was, to the best of our knowledge, first considered in <a href="https://doi.org/10.48550/ARXIV.2505.22034">Simensen et al. (2025)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/irregular/irregular_rules.jl#L489-L527">source</a></section></article><h4 id="Normalized-maximum-likelihood,-regular-(NML_R)"><a class="docs-heading-anchor" href="#Normalized-maximum-likelihood,-regular-(NML_R)">Normalized maximum likelihood, regular (NML_R)</a><a id="Normalized-maximum-likelihood,-regular-(NML_R)-1"></a><a class="docs-heading-anchor-permalink" href="#Normalized-maximum-likelihood,-regular-(NML_R)" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.NML_I" href="#AutoHist.NML_I"><code>AutoHist.NML_I</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NML_I(;
    grid::Symbol               = :regular,
    maxbins::Union{Int,Symbol} = :default,
    alg::AbstractAlgorithm     = DP()
)</code></pre><p>A quick-to-evalutate version of the normalized maximum likelihood criterion.</p><p>Consists of finding the partition <span>$\mathcal{I}$</span> that maximizes a penalized log-likelihood,</p><p class="math-container">\[\begin{aligned}
    &amp;\sum_{j=1}^k N_j\log \frac{N_j}{|\mathcal{I}_j|} - \frac{k-1}{2}\log(n/2) - \log\frac{\sqrt{\pi}}{\Gamma(k/2)} - n^{-1/2}\frac{\sqrt{2}k\Gamma(k/2)}{3\Gamma(k/2-1/2)} \\
    &amp;- n^{-1}\left(\frac{3+k(k-2)(2k+1)}{36} - \frac{\Gamma(k/2)^2 k^2}{9\Gamma(k/2-1/2)^2} \right)  - \log \binom{k_n-1}{k-1}
\end{aligned}\]</p><p><strong>Keyword arguments</strong></p><ul><li><code>grid</code>: Symbol indicating how the finest possible mesh should be constructed. Options are <code>:data</code>, which uses each unique data point as a grid point, <code>:regular</code> (default) which constructs a fine regular grid, and <code>:quantile</code> which constructs the grid based on the sample quantiles.</li><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code> if <code>grid</code> is <code>regular</code> or <code>quantile</code>. Ignored if <code>grid=:data</code>.</li><li><code>alg</code>: Algorithm used to fit the model. Currently, only <a href="../algorithms/#AutoHist.SegNeig"><code>SegNeig</code></a> is supported for this rule.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; rule = NML_I(grid = :data);

julia&gt; fit(AutomaticHistogram, x, rule)
AutomaticHistogram{Vector{Float64}, Vector{Float64}, Vector{Int64}}
breaks: [0.0, 0.18875598171056715, 0.3644223879547405, 0.8696799410193466, 1.0]
density: [0.116552597701164, 0.6717277510418354, 1.6229346697072502, 0.30693663211078037]
counts: [11, 59, 410, 20]
type: irregular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>This a variant of this criterion first suggested by <a href="https://proceedings.mlr.press/v2/kontkanen07a.html">Kontkanen and Myllymäki (2007)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/irregular/irregular_rules.jl#L329-L369">source</a></section></article><h4 id="Bayesian-Blocks-(BayesBlocks)"><a class="docs-heading-anchor" href="#Bayesian-Blocks-(BayesBlocks)">Bayesian Blocks (BayesBlocks)</a><a id="Bayesian-Blocks-(BayesBlocks)-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-Blocks-(BayesBlocks)" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.BayesBlocks" href="#AutoHist.BayesBlocks"><code>AutoHist.BayesBlocks</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BayesBlocks(;
    p0::Real                   = 0.05,
    grid::Symbol               = :regular,
    maxbins::Union{Int,Symbol} = :default,
    alg::AbstractAlgorithm     = OptPart(),
    use_min_length::Bool       = false
)</code></pre><p>Consists of finding the partition <span>$\mathcal{I}$</span> that maximizes a penalized Poisson likelihood criterion,</p><p class="math-container">\[    \sum_{j=1}^k N_j\log\big(N_j/|\mathcal{I}_j|\big) + k\big(4 - \log(73.53 p_0 n^{-0.478})\big).\]</p><p><strong>Keyword arguments</strong></p><ul><li><code>p0</code>: Hyperparameter controlling the penalty for the number of bins. Must be a number in the open interval <span>$(0,1)$</span>, with <code>p0 = 0.05</code> serving as the default.</li><li><code>grid</code>: Symbol indicating how the finest possible mesh should be constructed. Options are <code>:data</code>, which uses each unique data point as a grid point, <code>:regular</code> (default) which constructs a fine regular grid, and <code>:quantile</code> which constructs the grid based on the sample quantiles.</li><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code> if <code>grid</code> is <code>regular</code> or <code>quantile</code>. Ignored if <code>grid=:data</code>.</li><li><code>alg</code>: Algorithm used to fit the model. Currently, <a href="../algorithms/#AutoHist.OptPart"><code>OptPart</code></a> and <a href="../algorithms/#AutoHist.SegNeig"><code>SegNeig</code></a> are supported for this rule, with the former algorithm being the default.</li><li><code>use_min_length</code>: Boolean indicating whether or not to impose a restriction on the minimum bin length of the histogram. If set to true, the smallest allowed bin length is set to <code>(maximum(x)-minimum(x))/n*log(n)^(1.5)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; rule = BayesBlocks(grid = :data, use_min_length=true);

julia&gt; fit(AutomaticHistogram, x, rule)
AutomaticHistogram{Vector{Float64}, Vector{Float64}, Vector{Int64}}
breaks: [0.0, 0.1948931612779725, 0.375258352661302, 0.8268306249022703, 0.9222490305512866, 1.0]
density: [0.12314439276691318, 0.7096713008662634, 1.6962954704872724, 0.7545714006671028, 0.12861575966067232]
counts: [12, 64, 383, 36, 5]
type: irregular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>The Bayesian Blocks method was first introduced in <a href="https://doi.org/10.1088/0004-637X/764/2/167">Scargle et al. (2013)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/irregular/irregular_rules.jl#L570-L609">source</a></section></article><h2 id="Regular-histograms"><a class="docs-heading-anchor" href="#Regular-histograms">Regular histograms</a><a id="Regular-histograms-1"></a><a class="docs-heading-anchor-permalink" href="#Regular-histograms" title="Permalink"></a></h2><p>The following section details how each value of the <code>rule</code> argument selects the number <span>$k$</span> of bins to draw a regular histogram automatically based on a random sample. In the following, <span>$\mathcal{I} = (\mathcal{I}_1, \mathcal{I}_2, \ldots, \mathcal{I}_k)$</span> is the corresponding partition of <span>$[0,1]$</span> consisting of <span>$k$</span> equal-length bins. In cases where the value of the number of bins is computed by maximizing an expression, we look for the best regular partition among all regular partitions consisting of no more than <span>$k_n$</span> bins. For rules falling under this umbrella, <span>$k_n$</span> can be controlled through the <code>maxbins</code> keyword, as detailed below.</p><h4 id="Random-regular-histogram-(RRH),-Knuth"><a class="docs-heading-anchor" href="#Random-regular-histogram-(RRH),-Knuth">Random regular histogram (RRH), Knuth</a><a id="Random-regular-histogram-(RRH),-Knuth-1"></a><a class="docs-heading-anchor-permalink" href="#Random-regular-histogram-(RRH),-Knuth" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.RRH" href="#AutoHist.RRH"><code>AutoHist.RRH</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RRH(;
    a::Union{Real,Function}    = 5.0,
    logprior::Function         = k-&gt;0.0,
    maxbins::Union{Int,Symbol} = :default
)
Knuth(; maxbins::Union{Int,Symbol} = :default)</code></pre><p>The random regular histogram criterion.</p><p>The number <span>$k$</span> of bins is chosen as the maximizer of the marginal log-posterior,</p><p class="math-container">\[   n\log (k) + \sum_{j=1}^k \big\{\log \Gamma(a_j + N_j) - \log \Gamma(a_j)\big\} + \log p_n(k).\]</p><p>Here <span>$p_n(k)$</span> is the prior distribution on the number <span>$k$</span> of bins, which can be controlled by supplying a function to the <code>logprior</code> keyword argument.  The default value is <span>$p_n(k) \propto 1$</span>. Here, <span>$a_j = a/k$</span>, for a scalar <span>$a &gt; 0$</span>, possibly depending on <span>$k$</span>. The value of <span>$a$</span> can be set by supplying a fixed, positive scalar or a function <span>$a(k)$</span> to the keyword argument <code>a</code>. The default value is <code>a=5.0</code> for <code>RRH()</code>.</p><p>The rule <code>Knuth()</code> is a special case of the <code>RRH</code> criterion, which corresponds to the particular choices <span>$a_j = 0.5$</span> and <span>$p_n(k)\propto 1$</span>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>a</code>: Specifies Dirichlet concentration parameter in the Bayesian histogram model. Can either be a fixed positive number or a function computing aₖ for different values of k. Defaults to <code>5.0</code> if not supplied.</li><li><code>logprior</code>: Unnormalized logprior distribution on the number <span>$k$</span> of bins. Defaults to a uniform prior, e.g. <code>logprior(k) = 0</code> for all <code>k</code>.</li><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; rule = RRH(a = k-&gt;0.5*k, logprior = k-&gt;0.0);

julia&gt; h = fit(AutomaticHistogram, x, rule)
AutomaticHistogram{LinRange{Float64, Int64}, Vector{Float64}, Vector{Int64}}
breaks: LinRange{Float64}(0.0, 1.0, 11)
density: [0.04950495049504951, 0.2079207920792079, 0.5643564356435643, 1.0, 1.495049504950495, 1.8712871287128714, 1.9702970297029703, 1.6732673267326732, 0.9603960396039604, 0.2079207920792079]
counts: [2, 10, 28, 50, 75, 94, 99, 84, 48, 10]
type: regular
closed: right
a: 5.0

julia&gt; h == fit(AutomaticHistogram, x, Knuth())
true</code></pre><p><strong>References</strong></p><p>The <code>Knuth</code> criterion for histograms was proposed by <a href="https://doi.org/10.1016/j.dsp.2019.102581">Knuth (2019)</a>. The random regular histogram criterion is a generalization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/regular/regular_rules.jl#L10-L59">source</a></section></article><h4 id="AIC"><a class="docs-heading-anchor" href="#AIC">AIC</a><a id="AIC-1"></a><a class="docs-heading-anchor-permalink" href="#AIC" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.AIC" href="#AutoHist.AIC"><code>AutoHist.AIC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AIC(; maxbins::Union{Int,Symbol} = :default)</code></pre><p>AIC criterion for regular histograms.</p><p>The number <span>$k$</span> of bins is chosen as the maximizer of the penalized log-likelihood,</p><p class="math-container">\[    n\log (k) + \sum_{j=1}^k N_j \log (N_j/n) - k,\]</p><p>where <span>$n$</span> is the sample size.</p><p><strong>Keyword arguments</strong></p><ul><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; fit(AutomaticHistogram, x, AIC())
AutomaticHistogram{LinRange{Float64, Int64}, Vector{Float64}, Vector{Int64}}
breaks: LinRange{Float64}(0.0, 1.0, 11)
density: [0.04, 0.2, 0.56, 1.0, 1.5, 1.88, 1.98, 1.68, 0.96, 0.2]
counts: [2, 10, 28, 50, 75, 94, 99, 84, 48, 10]
type: regular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>The aic criterion was proposed by <a href="https://doi.org/10.1093/biomet/74.3.636">Taylor (1987)</a> for histograms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/regular/regular_rules.jl#L121-L151">source</a></section></article><h4 id="BIC"><a class="docs-heading-anchor" href="#BIC">BIC</a><a id="BIC-1"></a><a class="docs-heading-anchor-permalink" href="#BIC" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.BIC" href="#AutoHist.BIC"><code>AutoHist.BIC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BIC(; maxbins::Union{Int,Symbol} = :default)</code></pre><p>BIC criterion for regular histograms.</p><p>The number <span>$k$</span> of bins is chosen as the maximizer of the penalized log-likelihood,</p><p class="math-container">\[    n\log (k) + \sum_{j=1}^k N_j \log (N_j/n) - \frac{k}{2}\log(n).\]</p><p>where <span>$n$</span> is the sample size.</p><p><strong>Keyword arguments</strong></p><ul><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; fit(AutomaticHistogram, x, BIC())
AutomaticHistogram{LinRange{Float64, Int64}, Vector{Float64}, Vector{Int64}}
breaks: LinRange{Float64}(0.0, 1.0, 9)
density: [0.048, 0.336, 0.816, 1.44, 1.904, 1.904, 1.264, 0.288]
counts: [3, 21, 51, 90, 119, 119, 79, 18]
type: regular
closed: right
a: NaN</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/regular/regular_rules.jl#L189-L216">source</a></section></article><h4 id="Birgé-Rozenholc-(BR)"><a class="docs-heading-anchor" href="#Birgé-Rozenholc-(BR)">Birgé-Rozenholc (BR)</a><a id="Birgé-Rozenholc-(BR)-1"></a><a class="docs-heading-anchor-permalink" href="#Birgé-Rozenholc-(BR)" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.BR" href="#AutoHist.BR"><code>AutoHist.BR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BR(; maxbins::Union{Int,Symbol} = :default)</code></pre><p>Birgé-Rozenholc criterion for regular histograms.</p><p>The number <span>$k$</span> of bins is chosen as the maximizer of the penalized log-likelihood,</p><p class="math-container">\[    n\log (k) + \sum_{j=1}^k N_j \log (N_j/n) - k - \log^{2.5} (k),\]</p><p>where <span>$n$</span> is the sample size.</p><p><strong>Keyword arguments</strong></p><ul><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; fit(AutomaticHistogram, x, BR())
AutomaticHistogram{LinRange{Float64, Int64}, Vector{Float64}, Vector{Int64}}
breaks: LinRange{Float64}(0.0, 1.0, 11)
density: [0.04, 0.2, 0.56, 1.0, 1.5, 1.88, 1.98, 1.68, 0.96, 0.2]
counts: [2, 10, 28, 50, 75, 94, 99, 84, 48, 10]
type: regular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>This criterion was proposed by <a href="https://doi.org/10.1051/ps:2006001">Birgé and Rozenholc (2006)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/regular/regular_rules.jl#L253-L283">source</a></section></article><h4 id="Regular-L_2-leave-one-out-cross-validation-(L2CV_R)"><a class="docs-heading-anchor" href="#Regular-L_2-leave-one-out-cross-validation-(L2CV_R)">Regular <span>$L_2$</span> leave-one-out cross-validation (L2CV_R)</a><a id="Regular-L_2-leave-one-out-cross-validation-(L2CV_R)-1"></a><a class="docs-heading-anchor-permalink" href="#Regular-L_2-leave-one-out-cross-validation-(L2CV_R)" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.L2CV_R" href="#AutoHist.L2CV_R"><code>AutoHist.L2CV_R</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">L2CV_R(; maxbins::Union{Int,Symbol} = :default)</code></pre><p>L2 cross-validation criterion for regular histograms.</p><p>The number <span>$k$</span> of bins is chosen by maximizing a leave-one-out L2 cross-validation criterion,</p><p class="math-container">\[    -2k + k\frac{n+1}{n^2}\sum_{j=1}^k N_j^2.\]</p><p>where <span>$n$</span> is the sample size.</p><p><strong>Keyword arguments</strong></p><ul><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; fit(AutomaticHistogram, x, L2CV_R())
AutomaticHistogram{LinRange{Float64, Int64}, Vector{Float64}, Vector{Int64}}
breaks: LinRange{Float64}(0.0, 1.0, 11)
density: [0.04, 0.2, 0.56, 1.0, 1.5, 1.88, 1.98, 1.68, 0.96, 0.2]
counts: [2, 10, 28, 50, 75, 94, 99, 84, 48, 10]
type: regular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>This approach to histogram density estimation was first considered by <a href="https://www.jstor.org/stable/4615859">Rudemo (1982)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/regular/regular_rules.jl#L460-L490">source</a></section></article><h4 id="Regular-Kullback-Leibler-leave-one-out-cross-validation-(KLCV_R)"><a class="docs-heading-anchor" href="#Regular-Kullback-Leibler-leave-one-out-cross-validation-(KLCV_R)">Regular Kullback-Leibler leave-one-out cross-validation (KLCV_R)</a><a id="Regular-Kullback-Leibler-leave-one-out-cross-validation-(KLCV_R)-1"></a><a class="docs-heading-anchor-permalink" href="#Regular-Kullback-Leibler-leave-one-out-cross-validation-(KLCV_R)" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.KLCV_R" href="#AutoHist.KLCV_R"><code>AutoHist.KLCV_R</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KLCV_R(; maxbins::Union{Int,Symbol} = :default)</code></pre><p>Kullback-Leibler cross-validation criterion for regular histograms.</p><p>The number <span>$k$</span> of bins is chosen by maximizing a leave-one-out Kullback-Leibler cross-validation criterion,</p><p class="math-container">\[    n\log(k) + \sum_{j=1}^k N_j\log (N_j-1),\]</p><p>where <span>$n$</span> is the sample size and the maximmization is over all regular partitions with <span>$N_j \geq 2$</span> for all <span>$j$</span>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; fit(AutomaticHistogram, x, KLCV_R())
AutomaticHistogram{LinRange{Float64, Int64}, Vector{Float64}, Vector{Int64}}
breaks: LinRange{Float64}(0.0, 1.0, 11)
density: [0.04, 0.2, 0.56, 1.0, 1.5, 1.88, 1.98, 1.68, 0.96, 0.2]
counts: [2, 10, 28, 50, 75, 94, 99, 84, 48, 10]
type: regular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>This approach was first studied by <a href="https://doi.org/10.1007/BF01203164">Hall (1990)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/regular/regular_rules.jl#L527-L557">source</a></section></article><h4 id="Minimum-description-length-(MDL)"><a class="docs-heading-anchor" href="#Minimum-description-length-(MDL)">Minimum description length (MDL)</a><a id="Minimum-description-length-(MDL)-1"></a><a class="docs-heading-anchor-permalink" href="#Minimum-description-length-(MDL)" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.MDL" href="#AutoHist.MDL"><code>AutoHist.MDL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MDL(; maxbins::Union{Int,Symbol} = :default)</code></pre><p>MDL criterion for regular histograms.</p><p>The number <span>$k$</span> of bins is chosen as the minimizer of an encoding length of the data, and is equivalent to the maximizer of</p><p class="math-container">\[    n\log(k) + \sum_{j=1}^k \big(N_j-\frac{1}{2}\big)\log\big(N_j-\frac{1}{2}\big) - \big(n-\frac{k}{2}\big)\log\big(n-\frac{k}{2}\big) - \frac{k}{2}\log(n),\]</p><p>where <span>$n$</span> is the sample size and the maximmization is over all regular partitions with <span>$N_j \geq 1$</span> for all <span>$j$</span>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; fit(AutomaticHistogram, x, MDL())
AutomaticHistogram{LinRange{Float64, Int64}, Vector{Float64}, Vector{Int64}}
breaks: LinRange{Float64}(0.0, 1.0, 11)
density: [0.04, 0.2, 0.56, 1.0, 1.5, 1.88, 1.98, 1.68, 0.96, 0.2]
counts: [2, 10, 28, 50, 75, 94, 99, 84, 48, 10]
type: regular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>The minimum description length principle was first applied to histogram estimation by <a href="https://doi.org/10.1093/biomet/75.4.705">Hall and Hannan (1988)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/regular/regular_rules.jl#L321-L351">source</a></section></article><h4 id="Normalized-maximum-likelihood,-regular-(NML_R)-2"><a class="docs-heading-anchor" href="#Normalized-maximum-likelihood,-regular-(NML_R)-2">Normalized maximum likelihood, regular (NML_R)</a><a class="docs-heading-anchor-permalink" href="#Normalized-maximum-likelihood,-regular-(NML_R)-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.NML_R" href="#AutoHist.NML_R"><code>AutoHist.NML_R</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NML_R(; maxbins::Union{Int,Symbol} = :default)</code></pre><p>NML_R criterion for regular histograms.</p><p>The number <span>$k$</span> of bins is chosen by maximizing a penalized likelihood,</p><p class="math-container">\[\begin{aligned}
    &amp;\sum_{j=1}^k N_j\log \frac{N_j}{|\mathcal{I}_j|} - \frac{k-1}{2}\log(n/2) - \log\frac{\sqrt{\pi}}{\Gamma(k/2)} - n^{-1/2}\frac{\sqrt{2}k\Gamma(k/2)}{3\Gamma(k/2-1/2)} \\
    &amp;- n^{-1}\left(\frac{3+k(k-2)(2k+1)}{36} - \frac{\Gamma(k/2)^2 k^2}{9\Gamma(k/2-1/2)^2} \right).
\end{aligned}\]</p><p>where <span>$n$</span> is the sample size.</p><p><strong>Keyword arguments</strong></p><ul><li><code>maxbins</code>: Maximal number of bins for which the above criterion is evaluated. Defaults to <code>maxbins=:default</code>, which sets maxbins to the ceil of <code>min(1000, 4n/log(n)^2)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; fit(AutomaticHistogram, x, NML_R())
AutomaticHistogram{LinRange{Float64, Int64}, Vector{Float64}, Vector{Int64}}
breaks: LinRange{Float64}(0.0, 1.0, 24)
density: [0.046, 0.0, 0.138, 0.184, 0.368, 0.506, 0.69, 0.874, 1.104, 1.334  …  1.978, 1.978, 1.978, 1.84, 1.61, 1.334, 0.966, 0.644, 0.276, 0.046]
counts: [1, 0, 3, 4, 8, 11, 15, 19, 24, 29  …  43, 43, 43, 40, 35, 29, 21, 14, 6, 1]
type: regular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>This is a regular variant of the normalized maximum likelihood criterion considered by <a href="https://proceedings.mlr.press/v2/kontkanen07a.html">Kontkanen and Myllymäki (2007)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/regular/regular_rules.jl#L389-L422">source</a></section></article><h4 id="Sturges&#39;-rule"><a class="docs-heading-anchor" href="#Sturges&#39;-rule">Sturges&#39; rule</a><a id="Sturges&#39;-rule-1"></a><a class="docs-heading-anchor-permalink" href="#Sturges&#39;-rule" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.Sturges" href="#AutoHist.Sturges"><code>AutoHist.Sturges</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sturges()</code></pre><p>Sturges&#39; rule for regular histograms.</p><p>The number <span>$k$</span> of bins is chosen as</p><p class="math-container">\[    k = \lceil \log_2(n) \rceil + 1,\]</p><p>where <span>$n$</span> is the sample size.</p><p>This is the default procedure used by the <code>hist()</code> function in base R.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; fit(AutomaticHistogram, x, Sturges())
AutomaticHistogram{LinRange{Float64, Int64}, Vector{Float64}, Vector{Int64}}
breaks: LinRange{Float64}(0.0, 1.0, 10)
density: [0.054, 0.252, 0.666, 1.206, 1.71, 1.98, 1.782, 1.098, 0.252]
counts: [3, 14, 37, 67, 95, 110, 99, 61, 14]
type: regular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>This classical rule is due to <a href="https://doi.org/10.1080/01621459.1926.10502161">Sturges (1926)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/regular/regular_rules.jl#L590-L619">source</a></section></article><h4 id="Freedman-and-Diaconis&#39;-rule"><a class="docs-heading-anchor" href="#Freedman-and-Diaconis&#39;-rule">Freedman and Diaconis&#39; rule</a><a id="Freedman-and-Diaconis&#39;-rule-1"></a><a class="docs-heading-anchor-permalink" href="#Freedman-and-Diaconis&#39;-rule" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.FD" href="#AutoHist.FD"><code>AutoHist.FD</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FD()</code></pre><p>Freedman and Diaconis&#39; rule for regular histograms.</p><p>The number <span>$k$</span> of bins is computed according to the formula</p><p class="math-container">\[    k = \big\lceil\frac{n^{1/3}}{2\text{IQR}(\boldsymbol{x})}\big\rceil,\]</p><p>where <span>$\text{IQR}(\boldsymbol{x})$</span> is the sample interquartile range and <span>$n$</span> is the sample size.</p><p>This is the default procedure used by the <code>histogram()</code> function in <code>Plots.jl</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; fit(AutomaticHistogram, x, FD())
AutomaticHistogram{LinRange{Float64, Int64}, Vector{Float64}, Vector{Int64}}
breaks: LinRange{Float64}(0.0, 1.0, 16)
density: [0.03, 0.09, 0.24, 0.48, 0.78, 1.08, 1.44, 1.71, 1.92, 2.01, 1.89, 1.59, 1.08, 0.54, 0.12]
counts: [1, 3, 8, 16, 26, 36, 48, 57, 64, 67, 63, 53, 36, 18, 4]
type: regular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>This rule dates back to <a href="https://doi.org/10.1007/BF01025868">Freedman and Diaconis (1982)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/regular/regular_rules.jl#L677-L706">source</a></section></article><h4 id="Scott&#39;s-rule"><a class="docs-heading-anchor" href="#Scott&#39;s-rule">Scott&#39;s rule</a><a id="Scott&#39;s-rule-1"></a><a class="docs-heading-anchor-permalink" href="#Scott&#39;s-rule" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.Scott" href="#AutoHist.Scott"><code>AutoHist.Scott</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Scott()</code></pre><p>Scott&#39;s rule for regular histograms.</p><p>The number <span>$k$</span> of bins is computed according to the formula</p><p class="math-container">\[    k = \big\lceil \hat{\sigma}^{-1}(24\sqrt{\pi})^{-1/3}n^{1/3}\big\rceil,\]</p><p>where <span>$\hat{\sigma}$</span> is the sample standard deviation and <span>$n$</span> is the sample size.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; fit(AutomaticHistogram, x, Scott())
AutomaticHistogram{LinRange{Float64, Int64}, Vector{Float64}, Vector{Int64}}
breaks: LinRange{Float64}(0.0, 1.0, 14)
density: [0.026, 0.13, 0.338, 0.624, 0.988, 1.378, 1.716, 1.924, 2.002, 1.768, 1.3, 0.676, 0.13]
counts: [1, 5, 13, 24, 38, 53, 66, 74, 77, 68, 50, 26, 5]
type: regular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>This classical rule is due to <a href="https://doi.org/10.1093/biomet/66.3.605">Scott (1979)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/regular/regular_rules.jl#L634-L661">source</a></section></article><h4 id="Wand&#39;s-rule"><a class="docs-heading-anchor" href="#Wand&#39;s-rule">Wand&#39;s rule</a><a id="Wand&#39;s-rule-1"></a><a class="docs-heading-anchor-permalink" href="#Wand&#39;s-rule" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoHist.Wand" href="#AutoHist.Wand"><code>AutoHist.Wand</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Wand(;
    level::Int      = 2,
    scalest::Symbol = :minim
)</code></pre><p>Wand&#39;s rule for regular histograms.</p><p>A more sophisticated version of Scott&#39;s rule, Wand&#39;s rule proceeds by determining the bin width <span>$h$</span> as</p><p class="math-container">\[    h = \Big(\frac{6}{\hat{C}(f_0) n}\Big)^{1/3},\]</p><p>where <span>$\hat{C}(f_0)$</span> is an estimate of the functional <span>$C(f_0) = \int \{f_0&#39;(x)\}^2\, \text{d}x$</span>. The corresponding number of bins is <span>$k = \lceil h^{-1}\rceil$</span>.</p><p><strong>Keyword arguments</strong></p><p><code>level</code>: The <code>level</code> keyword controls the number of stages of functional estimation used to compute <span>$\hat{C}$</span>, and can take values <code>0, 1, 2, 3, 4, 5</code>, with the default value being <code>level=2</code>. The choice <code>level=0</code> corresponds to a varation on Scott&#39;s rule, with a custom scale estimate. <code>scalest</code>: Estimate of scale parameter. Possible choices are <code>:minim</code> <code>:stdev</code> and <code>:iqr</code>. The latter two use sample standard deviation or the sample interquartile range, respectively, to estimate the scale. The default choice <code>:minim</code> uses the minimum of the above estimates.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0.0, 1.0, 500)) .^(1/3)).^(1/3);

julia&gt; rule = Wand(scalest=:stdev, level=5);

julia&gt; fit(AutomaticHistogram, x, rule)
AutomaticHistogram{LinRange{Float64, Int64}, Vector{Float64}, Vector{Int64}}
breaks: LinRange{Float64}(0.0, 1.0, 13)
density: [0.024, 0.144, 0.408, 0.72, 1.128, 1.536, 1.872, 1.992, 1.848, 1.416, 0.744, 0.168]
counts: [1, 6, 17, 30, 47, 64, 78, 83, 77, 59, 31, 7]
type: regular
closed: right
a: NaN</code></pre><p><strong>References</strong></p><p>The full details on this method are given in <a href="https://doi.org/10.2307/2684697">Wand (1997)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/AutoHist.jl/blob/176cead6bb82b603569a00940d572033d779a629/src/regular/regular_rules.jl#L727-L763">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#AutoHist.AIC"><code>AutoHist.AIC</code></a></li><li><a href="#AutoHist.BIC"><code>AutoHist.BIC</code></a></li><li><a href="#AutoHist.BR"><code>AutoHist.BR</code></a></li><li><a href="#AutoHist.BayesBlocks"><code>AutoHist.BayesBlocks</code></a></li><li><a href="#AutoHist.FD"><code>AutoHist.FD</code></a></li><li><a href="#AutoHist.KLCV_I"><code>AutoHist.KLCV_I</code></a></li><li><a href="#AutoHist.KLCV_R"><code>AutoHist.KLCV_R</code></a></li><li><a href="#AutoHist.L2CV_I"><code>AutoHist.L2CV_I</code></a></li><li><a href="#AutoHist.L2CV_R"><code>AutoHist.L2CV_R</code></a></li><li><a href="#AutoHist.MDL"><code>AutoHist.MDL</code></a></li><li><a href="#AutoHist.NML_I"><code>AutoHist.NML_I</code></a></li><li><a href="#AutoHist.NML_R"><code>AutoHist.NML_R</code></a></li><li><a href="#AutoHist.RIH"><code>AutoHist.RIH</code></a></li><li><a href="#AutoHist.RMG_penA"><code>AutoHist.RMG_penA</code></a></li><li><a href="#AutoHist.RMG_penB"><code>AutoHist.RMG_penB</code></a></li><li><a href="#AutoHist.RMG_penR"><code>AutoHist.RMG_penR</code></a></li><li><a href="#AutoHist.RRH"><code>AutoHist.RRH</code></a></li><li><a href="#AutoHist.Scott"><code>AutoHist.Scott</code></a></li><li><a href="#AutoHist.Sturges"><code>AutoHist.Sturges</code></a></li><li><a href="#AutoHist.Wand"><code>AutoHist.Wand</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../examples/plotting/">Plotting tutorial »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Thursday 18 September 2025 11:17">Thursday 18 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
